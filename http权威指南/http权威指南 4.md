## 四、连接管理

### TCP/IP连接

* 一旦TCP/IP连接建立，服务器和客户端之间交换的报文就永远不会丢失、受损或失序。

* 浏览器从接收到url起：

  1. 解析主机名

  2. 查询主机名对应的IP，DNS解析。

  3. 获取端口号

  4. 浏览器发起到目标服务器端口的连接。

  5. 发送请求报文

  6. 读取响应报文

  7. 浏览器关闭连接

     <img src=".\noteimages\浏览器运行过程.PNG" style="zoom:50%;" />

* TCP连接：

  * HTTP连接实际上就是TCP连接和一些使用规则。

  * TCP为HTTP提供了一条可靠的bit传输管道，一端填入的字节会从另一端以原有顺序、正确的传送出来。

  * TCP数据通过IP分组（IP数据报）的小数据块发送的。

  * HTTP位于`HTTP over TCP over IP`协议栈的最顶层。

    HTTPS则是再HTTP与TCP之间加入了一个TLS或SSL密码加密层。

  * HTTP传输报文时，会以流的形式将报文内容通过一条打开的TCP连接按序传输。TCP会将数据流砍成小数据块（TCP段），并将其封装到IP分组中，通过网络进行传输。该过程由TCP/IP软件处理，对于HTTP程序员透明。

  * 每个TCP段由IP分组承载，从一个IP地址发送到另一个IP地址。每个IP分组包括：

    * IP分组首部，20 bytes。

      包含源和目的IP地址、长度和一些其他标记。

    * TCP段首部，20 bytes。

      包含TCP端口号、TCP控制标记、用于数据排序和完整性检查的值。

    * TCP数据块，任意字节。

    <img src=".\noteimages\HTTP和HTTPS协议栈.PNG" style="zoom:50%;" />

* TCP端口号：

  * TCP连接通过4个值来唯一的识别一条连接：源IP地址 源端口号 目的IP地址 目的端口号。

    可以有多个连接共用一个源端口/目的端口，但不能有2个连接这4个值完全一致。

* TCP Socket：Socket是OS提供的操纵TCP连接的API，向HTTP程序员隐藏了TCP/IP的所有细节（比如底层网络协议握手细节，IP分组对TCP数据流的分段重装细节等）。

  所有OS和语言都会有Socket或其变体。

  套接字的作用：

  * 允许用户创建TCP端点数据结构，与服务器的TCP端点进行连接。
  * 以数据流的形式进行读写。

  这些作用均可在java的socket中得到充分体现。

* TCP握手：

  1. 客户端向服务器请求新的TCP连接，向服务器发送一个小TCP分组（40-60bytes），分组中设置一个特殊的SYN标记，说明是一个连接请求。

  2. 服务器接受连接，回送一个TCP分组，对SYN和ACK进行置位。

  3. 客户端向服务器发送确认信息，通知连接已成功建立。

     客户端可以在确认分组中发送数据。

* TCP延迟确认：

  * Internet允许路由器在超负荷时，随意丢弃分组，因此无法保证可靠传输。

  * TCP的确认机制：
    * 每个TCP段都有一个序列号和数据完整性校验和。
    * 接收者收到完好的段时，会向发送者回送小的确认分组。
    * 如果发送者没在窗口时间内收到确认分组，会认为分组已被损坏，重发。
    
    TCP允许同向的输出数据分组对确认分组进行“捎带”。延迟确认算法会在一个特定的窗口时间内将输出确认分组存放在缓冲区，以寻找能够捎带的输出分组。窗口时间内若没有输出数据分组，则单独发送确认分组。

* TCP慢启动：

  TCP会随着时间进行自我“调谐”。

  * 起初会限制连接最大速度。
  * 如果数据成功传输，会随着时间的推移提高传输速度。
  * 防止Internet突然过载和拥塞。

  实现：

  * TCP慢启动限制一个TCP端点在任意时刻可以传输的分组数。
  * 每成功接收一个分组，发送端就有了发送另2个分组的权限。
  * 如果某个HTTP事务有大量数据要发送，不能一次发送所有分组，而是1个=》2个=》4个，随着每个分组被确认逐渐增多。
  * 这种方式称为“打开拥塞窗口”。

  因为这种拥塞控制特性，新连接会比“已调谐”的连接慢一些。

* Nagle算法：
  * 为什么要有：TCP允许将任意尺寸的数据（即使是1byte）放入TCP栈中。如果发送大量只包含少量数据的分组，由于每个分组都需要至少40 bytes的标记和首部，会导致网络性能严重下降。
  * Nagle算法：试图在发送一个分组之前，将大量TCP数据绑定到一起。
    * 鼓励发送全尺寸的段。
      * 在LAN上大约1500 bytes。
      * Internet上为几百bytes。
    * 只有所有其他分组都被确认，才允许发送非全尺寸的分组。
    * 否则缓存数据，直到缓存中攒够了一个全尺寸分组的数据时，才发送。
  * 会引起的问题：
    * 小的HTTP报文可能无法填满一个全尺寸分组，白白等待而造成时延。
    * Nagle算法与延迟确认之间的交互存在问题：Nagle算法阻止数据发送，这会导致确认分组本身被Nagle算法延迟。
    * HTTP app可以通过设置参数TCP_NODELAY以禁用Nagle算法，提高性能。确保向TCP写入大块数据时，可以选择禁用。

* TIME_WAIT累积问题：MSL 暂时看不懂，先跳过

### HTTP连接

* Connection首部：
* 串行事务处理时延：如果总是先加载HTML页面，再依次请求嵌入的对象（图片等），会导致加载很慢，且对加载进度一无所知。

  * 有以下几种方式提高性能：
    1. 并行连接
    2. 持久连接
    3. 管道化连接
    4. 复用连接
* 并行连接：HTTP允许client打开多条连接，并行的执行多个HTTP transactions，每一个事务都有自己的TCP连接。

  * 如果客户端网络带宽不足（一个或几个HTTP连接就占据了全部带宽），则并行连接不会提高性能。
  * 但用户能看到多个组件对象正在页面上加载，能感觉更快一些。

#### 持久连接

* 站点本地性site locality：指初始化了对某服务器HTTP请求的应用程序可能将对服务器发起更多请求，比如一个web页面的内嵌图片都来自同一个站点。
* 持久连接：

  * HTTP/1.1允许HTTP设备在transaction结束后将TCP连接保持在打开状态，供未来的HTTP请求重用。这种在transaction结束后仍保持打开状态的TCP连接称为持久连接。
  * 非持久连接会在transaction结束后关闭，持久连接会在不同的transaction之间保持打开状态，直到客户端或服务器决定将其关闭。
  * 持久连接可以避免缓慢的连接建立阶段，以及慢启动的拥塞适应阶段。
  * 持久连接有两种类型：
    * keep-alive：较老。
    * persistent：现代。
  * keep-alive：由HTTP/1.0版本提出，客户端可以通过包含`Connection：Keep-Alive`首部请求将一条连接保持在打开状态。

    * 提供了`Connection：Keep-Alive`首部后，可以通过可选首部Keep-Alive发送一些预估值，比如timeout、max等。

    * 服务器可以通过`Connection：Keep-Alive`响应首部向客户端表明发出响应之后是否会关闭连接。
    * 实体的主体部分必须有正确的Content-Length和多媒体类型，或者使用分块传输编码，以便另一端可以在无需检测连接关闭的情况下，确定报文实体的主体部分长度。否则会导致无法精确检测出一条报文的结束和另一条报文的开始。
    * 问题：盲中继(blind relay)代理会造成哑代理问题。
    * Connection首部为逐跳首部，代理和中继在对报文进行转发时，应删掉Connection首部，以及里面指定的字段。
  * HTTP/1.1持久连接persistent connection：

    * HTTP/1.1 当中持久连接是默认激活的，通过显示在报文中添加`Connection:close`首部来关闭
    * 。。。

#### 管道化连接

​	HTTP/1.1允许在持久连接上使用请求管道，在响应到达之前将多条请求放入队列，每一条请求不必等上一条响应到达之后再发送。

* 必须确认连接是持久的，才能使用管道。
* 响应必须按照与请求相同的顺序回送。因为HTTP报文没有序列号标签，因此如果失序就无法与请求进行匹配。
* 客户端需做好连接任意时刻关闭，重发未完成的管道化请求的准备，因此不应用管道化的方式发送POST等会产生副作用的请求。

#### 关闭连接

* 所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP连接，但服务器无法确定在关闭时客户端是否有要发送的数据。

* 响应通过Content-Length首部描述响应主体的尺寸。

* 幂等：一个transaction，不管执行一次还是多次，得到的结果都相同。

  * GET, HEAD, PUT, DELETE, TRACE, OPTIONS方法都应当是幂等的。

  * 客户端不应以管道化的方式发送非幂等请求，比如POST。
  * 发送非幂等请求，应先等待前一条请求的响应状态。

* 正常的关闭连接：

  * 完全关闭：将应用程序的TCP输入和输出信道都关闭，通过socket调用close()进行。

    半关闭：单独关闭输入/输出信道，通过socket调用shutdown()进行。

  * 关闭输出信道是总是安全的，另一端会从缓冲区中读出所有数据后收到流结束的通知，从而得知你将连接关闭。

  * 在不知道另一端是否会发送其他数据的情况下，关闭输入信道比较危险。

    ​	因为对端向已关闭的输入信道发送数据，会导致你的OS向对端回送“TCP连接被对端重置”的报文，导致对端清除缓冲区中所有未读取的数据。

    ​	比如客户端在持久连接上向服务器发送了10条管道式请求后，服务器关闭输入信道，客户端又发送第11条请求，会发送到已关闭的连接，导致服务器会送一条重置信息，清空客户端缓存的前10条响应数据。

  * 正常关闭：应用程序先关闭输出信道，然后等对端关闭其输出信道。

