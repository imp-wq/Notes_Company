# 原型和原型链

### 函数对象的prototype

* 获取原型的方式：
  * 标准：`Object.getPrototypeOf(obj)`
  * 非标准：`obj.__proto__`，浏览器实现的。

* 对象属性查找顺序：
  * 先在对象本身上找。
  * 如果没有，再去对象原型上找。
* 函数对象的原型：
  * 函数也可以通过Object.getPrototypeOf获取其对象原型（或叫隐式原型），函数中很少用。
  * 函数对象可以通过特有的prototype属性，获取其函数原型（显示原型）。

* new操作符，构造函数执行流程：

  ```js
  new Person()
  ```

  1. 创建空对象

     ```js
     const obj = {}
     ```

  2. 将空对象赋值给this

     ```js
     this = obj
     ```

  3. 将函数的显示原型赋值给该对象，作为其隐式原型。

     ```js
     Object.getPrototypeOf(obj) = Person.prototype
     ```

  4. 执行函数体中的代码。

  5. 将这个对象默认返回。

* 函数prototype的作用：

  * 构造函数中，通过`this.xxx = function ...`声明的方法，会在每个实例对象中单独创建自己的方法（===判断为false）。
  * 通过`构造函数.prototype.xxx = function ...`声明的方法，所有实例对象都会通过原型链访问同一个方法（===判断为true）。
  * 可以将所有对象共享的属性/方法，放到构造函数的prototype上。
  * 箭头函数没有prototype。

* constructor：

  * 函数prototype中的constructor属性，指向当前函数对象。

    即存在`fn.prototype.constructor === fn`恒为true的关系。

  * 实例对象的原型（由Object.getPrototypeOf得到）的constructor指向其构造函数。

* 重写原型对象：如果需要为prototype添加很多property，可以直接将其重写。
  * 重写时需要为其添加constructor，手动使其指向函数对象。
  * 但需注意，原本的constructor并非enumerable property（无法通过Object.keys获取到），因此应对其设置descriptor。

### ES5面向对象

​	封装，继承，多态。

* 原型链机制：

  * 所有对象类型的原型（getPrototypeOf或`__proto__`）指向Object.prototype（即Object的原型对象，Object构造函数的显示原型），Object原型对象的隐式原型指向null。

    ```js
    const obj = {}
    // 等价于
    // 通过Object构造函数实例化。
    const obj = new Object()
    ```

  * 查找对象属性的顺序：

    1. obj本身
    2. obj的原型，即Object构造函数的prototype，Object原型对象。
    3. Object原型对象的原型，即null。此时会返回undefined。

  * 利用原型链实现继承：借用构造函数constructor stealing。

    * 通过借用父类构造函数，并绑定子类对象的方式实现继承。

      `父类构造函数.call(this,父类构造函数参数列表)`

    * 通过call方法绑定this，使父类构造函数为子类的对象绑定属性，因此子类构造函数中无需重复写父类已有属性的代码。

    * 经社区长期总结对于继承的最佳实践。

* 组合继承：

  * 即通过将父类的对象赋值给子类的prototype实现方法的继承，通过借用构造函数实现属性的继承。
  * 问题：将父类的对象作为子类的prototype仍很奇怪，父类的构造函数会调用2次，且子类会有2份父类的属性。

* 原型式继承函数Prototypal Inheritance in JS：

  * 由JSON的创始者Douglas提出。
  * 通过构造一个对象，使其隐式原型指向父类构造函数的prototype（`Object.create(obj)`创建出的对象会使其隐式原型指向obj），将其作为子类构造函数的prototype。
  * 再通过defineProperty为子类的prototype定义constructor属性和configurable、writable等descriptors。

* Object是所有类的父类：

  * 所有对象的父类对象的隐式原型（`__proto__`）最终都会指向Object的显示原型（即构造函数Object的prototype）。

  * 在Object原型（`Object.prototype`）上的所有属性都能被所有对象访问到。

  * 一些Object静态方法：

    * entries：返回一个数组，数组元素为`[key,value]`形式，遍历一个对象本身的键值对，不会遍历其原型链。

  * 对象方法：

    * hasOwnProperty：判断对象自身身上是否有该属性，不包括对象原型。

    * in：in操作符会判断属性是否在对象上，或在对象的原型上。

    * for in：遍历对象和原型对象上的所有可枚举属性。

    * A instanceof B：判断A对象是否是B对象/构造函数的实例，即B是否出现在A的原型链上。

      判断对象和类/构造函数之间的关系。

      `stu instanceof Student`

    * isPrototypeOf：用于检测某个对象，是否出现在某个实例对象的原型链上。

      判断对象和对象之间的关系。

      `stu instanceof Student.prototype`

      可以用于判断对象之间的继承。
  
      
  
      