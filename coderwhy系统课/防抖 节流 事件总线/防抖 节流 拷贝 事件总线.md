# 防抖 节流 拷贝 事件总线

​	对于某些频繁的事件处理会造成性能损耗，可以通过防抖和节流来限制事件的发生。

## 防抖

* 基本概念：当事件触发时，相应函数不会立即触发，而是等待一定时间。等待时如果事件再次频繁密集触发，函数触发将被频繁推迟。只有等待了一段时间没有触发事件后，事件函数才会真正执行。
* 应用场景：输入框、浏览器滚动、浏览器的resize。
* 实现：
  * 执行事件函数时应清空timer，保证每次执行结束变量都回到初态。
  * 内部返回函数_debounce不应使用箭头函数，以便调用传入的fn时通过apply(this)绑定this。
  * 通过剩余参数和apply进行传参。

## 拷贝

### 浅拷贝

* Object.assign(target, source)：有展开运算符之后就用的少了。
* 展开运算符spread syntax

### 深拷贝

​	JS默认没有提供深拷贝的方法。

* JSON方法：

  问题：

  * 无法拷贝function、symbol类型的字段，因此JSON.stringify无法将这些字段转化为字符串（转化时会忽略这些字段）。

  * 如果存在对象的循环引用（环状结构），JSON.stringify会报错。
  * 对于Set等数据结构JSON.stringfy也只会转化成空对象，无法正常拷贝。

* 编写深拷贝函数：

  * isObject函数：判断是否为对象，在框架中很常用的函数。
    * null：typeof null也会返回`'object'`，但希望null返回false。
    * function：typeof 函数会返回`'function'`，但希望也会返回true（将函数也当成对象）。

  1. 如果传入的不是对象，直接返回。

  2. 使用for-in判断所有value，如果是对象，递归进行深拷贝，如果不是对象，直接赋值。

     直接利用递归实现。

  3. 一些特殊类型处理：

     * Array：不能用typeof判断是否是Array，因为返回都为object，需要通过Array.isArray方法。

     * Set：对于Set类型，只支持for-of遍历（因为是iterable对象），使用for-in遍历不出来东西。因此需要特殊处理。

     * Function：如果是函数，一般不进行深拷贝。

     * value为Symbol：如果是symbol类型，则根据其的descripton创建一个新的symbol。注意判断需要放到!isObject之前，因为symbol不会被判定为对象。

     * key为Symbol：for-in循环无法遍历Symbol类型的key。因此需要使用`Object.getOwnPropertiesSymbols`方法单独对Symbol类型的key进行遍历。

       可以用相同的description创建一个新的symbol key。

  4. 对循环引用的处理：通过weakMap保存已拷贝过的对象，对于已经深拷贝过的对象，直接从map中返回。

     优化：使用WeakMap而不是Map以便于回收内存空间，将weakMap以默认参数的形式传入，既能保证函数执行结束后销毁，又能保证递归调用时用的是同一个map。

## 事件总线

​	event-bus，是一个对象，用于注册/监听事件。

* 通过eventMap保存每个事件对应的函数队列，on的时候push，emit的时候依次调用。
* 传参。

