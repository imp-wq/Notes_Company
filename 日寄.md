## 9.28

* js doc

## 9.27

* ts：如果对象的key为string字面量类型（字符串枚举），应当使用in运算符：

  ```ts
  const headers = [
    { prop: 'num', label: '序号' },
    { prop: 'procedureName', label: '手续名称' },
    { prop: 'applyTime', label: '申请时间' },
    { prop: 'acceptTime', label: '批准时间' },
    { prop: 'stateLabel', label: '办理状态' },
    { prop: 'unitName', label: '批准机关' },
    { prop: 'docNo', label: '批准文号' },
    { prop: 'showDownload', label: '批复文件' }
  ] as const
  
  type dataElement = {
    [key in typeof headers[number]['prop']]: string
  }
  
  const data: Array<dataElement> = []
  ```

  

## 9.26

* 中台

## 9.25

* serach时，使用watch的好处：watch会自动对比新值和旧值，两者相等时避免不必要的请求。

  ```ts
  const requestParams_init = {
    pageNum: 1,
    pageSize: 8,
    projectName: ''
  }
  // 注意！这里如果需要使用初始对象来清空响应式对象，需要对其进行浅拷贝。否则通过reactive修改proxy，会导致原始对象的修改！
  const requestParams = reactive<getParamsTypeOfAPI<typeof globalSearchList>>({...requestParams_init})
  const reset = () => {
         
    Object.assign(requestParams, requestParams_init)
  }
  
  watch(requestParams, getData, { immediate: true })
  
  ```

  

* 一种对于axios的封装：

  注意箭头函数参数使用泛型：`const fun = <T>(params) => 'abcde'`

  ```ts
  const request = {
    get: (url: string) => (params: string) =>
      _request({
        url: `${url}${params}`,
        method: 'get'
      }),
    post:
      <T extends object>(url: string) =>
      (params: T) =>
        _request({
          url,
          data: params,
          method: 'post'
        })
  }
  ```

  

* vue reactive：

  * 取出reactive对象的对象类型字段，应该也是reactive。应该是因为reactive是递归的做成的。

    ```js
    const obj = reactive({ a: 'aaaa', b: { name: 'aaaa' } })
    console.log('b:', obj.b) // obj.b是一个reactive对象
    ```

    

* vscode snippet 变量：

  * 可以通过$1来指定snippet生成后的光标位置，多个$1会出现多个光标一起修改。
  * `${1:test},${1|aaaa,bbb,ccc|}`来设置一个或多个默认值。
  * 可以通过`$变量名`的形式获取一些变量，比如当前时间、文件名、路径等。



## 9.23

* grid布局：
  * 可以对item使用`grid-column-start`、`grid-column-end`来控制该表格的列（左边框和右边框）的起止位置，从而让单个单元格占好几个位置。row同理。注意该数字从1开始，类似nth-child选择器的数字。
  * 单位：fr，1个单元格位置，类似flex布局中的flex：1。



## 9.22

* element plus 弹窗dialog组件，设置class时，配合vue的scoped会出问题，data-xxx不会加到弹窗组件上。

  只能使用css module解决该问题。

* defineEmits:

  ts调用签名call signatures，以如下形式声明emits，能获得更好的ts提示。

  [TypeScript: Documentation - More on Functions (typescriptlang.org)](https://www.typescriptlang.org/docs/handbook/2/functions.html#call-signatures)

  ```vue
  const emits = defineEmits<{ (event: '事件名',params:参数类型) }>()
  ```

  

* scss：

  *  @include 引用mixin，@mixin能以类似函数的形式使用scss。

  ```scss
  @mixin 名称(变量) {};
  
  @include 名称(参数);
  ```

  * scss 在@use和@import时无法使用路径别名，不知道为什么。
  * scss interpolation插值语法，`#{变量名}`

* new Array(length)，可以配合fill方法快速创建由同一个对象填充的数组。

* css cursor
  * default：普通箭头
  * pointer：手
  * not-allowed：禁止符号

* chrome中隐藏滚动条的方法：

  `.some-element`代表先要用选择器选择需要隐藏滚动条的元素。

  ```css
  .some-element::-webkit-scrollbar {
      display: none;
  }
  ```

  

## 9.20

* 在vue2中，v-for循环对象时并不是for-in循环，而更类似数组的高阶函数，即参数为`(value,index,arr)`的形式，只不过对象的index是key。不知道vue3中是不是也这样。



## 9.15

* mitter事件总线、underscore防抖节流 源码

## 9.9

* map、set这些容器能否通过.来访问成员？



## 9.5

* vite中对于import函数的动态加载，hot module replacement可能不那么好使，有时报错需要重新yarn dev一下。
* css：apperance：none; 用于关闭原生的样式。



## 9.2

* vue动态组件：

  `<component :is="tabs[currentTab]"/>`

  * 动态组件是通过name来切换组件的，因此被动态切换的组件必须正确配置name property。

* 拖拽功能：
  * 如何判断拖拽到正确位置，显示`+`



## 9.1

* 常州 大屏拖拽：

  * 指标项index组件，应该是为了让子组件采用动态加载，节约性能。

  

## 8.24

* vue中字符串如果需要使用换行符换行，需要加上样式`white-space: pre-wrap;`才能使换行符生效。
* 行内元素、行内块元素在使用margin:auto居中时，需要转换成块元素。比如img。





------



## 7.28

重大活动管理

* vite

  * vite中使用tsx：
    * jsx需要引入插件vuejsx
    * ts直接lang="ts"或lang="tsx"即可

* vue3+ts

* >Enable Preview
  >
  >控制打开的编辑器是否显示为预览编辑器。预览编辑器不会保持打开状态，在将其显式设置为保持打开(例如通过双击或编辑)前将会重复使用，其文件名显示样式为斜体。
  >

* defineComponent:

  应该是因为在顶层setup中，没有export defualt，因此通过该API定义组件以供导出。

  起到一个类似函数式组件的效果。

### tsx

* 泛型组件
* vue中无法在tsx中使用的组件：
  * v-on：需要像react一样写成`on事件名`
  * v-for：需要像react一样用map

## 7.29

* vite中import()函数不能动态导入，不能接收变量
* ts中如何只为对象的某一字段指定类型？

### vueRouter

* setup函数与setup语法糖：

  * useRouter等hooks只能在setup中使用，如果单独封装函数，应当把router对象作为参数传入。
  * setup函数中，props需要单独作为options定义，不能使用defineProps。

  

* 原本的route路径对象通过router.currentRoute.value获取，比如可以通过`router.currentRoute.value.path`获取当前页面的路由

* 可以通过router.getsRoute和router.addRoute获取当前路由，判断，再注册新路由。

## 8.1

### jsx插槽

* 父组件：以对象形式，直接在子组件textNode部分传值，以对象形式，每个插槽传一个返回jsx的函数。

  ```jsx
  setup() {
      const slot = () => <h2>test</h2>
      return () => (
          <div className="Father-container">
          <h2 >Father组件</h2>
          <Son>
          {{
          customSlot: slot,
          default: () => <h2>default</h2>
  }}
      </Son>
  </div>
  )
  }
  ```

* 子组件

  * setup通过context.slots拿到所有插槽。
  * 以调用函数的形式`default?.()`来使用插槽，注意类型判断。

  ```js
   setup(props, { slots }) {
          console.log(slots)
          console.log(slots.customSlot)
          return () => (
              <>
                  <h2>Son组件</h2>
                  {slots.customSlot?.()}
                  {slots.default?.()}
              </>
          )
      }
  ```

  

* 待会再看看作用域插槽如何传值

## 8.4

* vue `<Transition>`中的组件，使用jsx时，不能用`<></>`包裹，否则会导致组件不动（can not be animated）。

* https://www.typescriptlang.org/
* ts declare 命名空间的问题 vite

## 8.5

* ref变量在tsx挂载到DOM attr上时，不可以自动浅解包。

  DOM text也不行。tsx应该就不能自动浅解包。

* vscode复制路径，设置分隔符： Copy Relative Path Separator

* vue3 expose：

  * 子组件暴露：

    这里list为响应式数据，直接暴露。

    ```vue
    const list = ref([])
    
    expose({ list })
    ```

  * 父组件访问：

    通过ref直接拿到expose的对象。

    ```jsx
    <ReactiveTable requestList={listMonitor} ref={reactiveTableExpose} />
    ```

    直接通过

    ```js
    reactiveTableExpose?.value?.list
    ```

    拿到list。这里的list类型是Reactive(Array[])，即响应式数据

## 8.7

* Object.defineProperty(obj,key,{value,writable,configurable})

  writable和configurable默认为false，即如果只传入一个value，该property不可修改也不可删除。

## 8.8

* vue应该只能在组件的render函数的jsx中使用组件，无法在普通jsx中注册并使用组件。

## 8.10

* vite 2中只能使用较老版本的plugin-vue-jsx，现在用的1.3.3，具体版本对应还不太清楚。
* api json取数据时首字母要大写。

## 8.11

* echarts:多个y轴时，series中的data需要通过yAxisIndex进行匹配。

* js在对象中使用对象解构是有顺序的，与普通赋值一样，后赋值的覆盖先赋值的。

  ```js
  const obj1 = { a: 123, b: 'qwer' }
  const obj2 = { a: 2222, b: 'tttt', ...obj1 } // {a:123,b:'qwer'}
  const obj3 = { ...obj1, a: 2222, b: 'tttt' } // {a:2222,b:'tttt'}
  ```

* js的`array.join()`方法不传参时默认分隔符为`,`，如果需要空字符串的话要手动传入。

* 扩展运算符可以将string解构为arr：

  ```js
  [...'hello']
  ```

* grid布局：

  * 四宫格

    * content：

      ```css
        display: grid;
        grid-template-columns: 50% 50%;
        grid-template-rows: 50% 50%;
      ```

    * item：

  * 三盒子并排：

    ```css
      display: grid;
      grid-template-columns: repeat(3, 33.3%);
      column-gap: 10px;
    ```

    

* import.meta.glob怎么用？

  动态url引入问题

## 8.13

* string.padStart/string.padEnd  (targetLength,paddingString)：使用paddingString将字符串填充到目标长度，从头/尾部开始填充，重复填充。
  * 可用于使用空格让两组字符串之间的距离相等。

## 8.15

* git reflog 可以查看本地的一些日志 

* js 函数 使用默认参数，如果调用时手动传入undefined，也会使用默认参数。

* 如果使用

  ```js
  if(!res.xxx) {throw 'error'}
  ```

  这样的方式来判断该字段是否存在，可能会将值为数字0的字段也筛出去。

  可以使用

  ```js
  if(res.xxx == undefined) {throw 'error'}
  ```

* vue中如果使用reactive([])数组的forEach，对数组中的对象元素赋值，会出现问题。

* vue中也可以像react一样使用css module：
  * css标签加上module，替代原先scoped。

  * setup中使用useCssModule()钩子获得当前sfc的css模块。

  * 使用方法与react相同。

  * 多类名可以使用如下方式：

    ```js
    style={['className1','className2'].join(' ')}
    ```

  * vue sfc scoped不会为script标签中，return函数中以外的部分添加hash值，因此如果在render函数以外使用jsx元素，会导致样式挂不到相应的类名上。

## 8.16

* echarts通过series中的label选项来显示对应数字，但symbol如果为none，label也不会显示。
* MDN：CSS **`linear-gradient()`** 函数用于创建一个表示两种或多种颜色线性渐变的图片，只能被用在image用的地方。
* try-catch不能捕获setTimeOut的异常，需要使用window.onerror

* echarts 手机端 不能识别十六进制的rgba格式颜色。

## 8.22

* yarn 源管理：yrm。

## 8.23

* 笔记本双屏：显示设置里，设置为扩展屏幕（不要设置成复制），根据设置的位置，鼠标可以进入扩展屏幕进行操作。

* ??运算符：当左边为null和undefined时，返回右边的值。用于设置默认值。

  注意不包括空字符串''。

  
