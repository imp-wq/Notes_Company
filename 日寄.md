## 9.5

* vite中对于import函数的动态加载，hot module replacement可能不那么好使，有时报错需要重新yarn dev一下。
* css：apperance：none; 用于关闭原生的样式。



## 9.2

* vue动态组件：

  `<component :is="tabs[currentTab]"/>`

  * 动态组件是通过name来切换组件的，因此被动态切换的组件必须正确配置name property。

* 拖拽功能：
  * 如何判断拖拽到正确位置，显示`+`



## 9.1

* 常州 大屏拖拽：

  * 指标项index组件，应该是为了让子组件采用动态加载，节约性能。

  

## 8.24

* vue中字符串如果需要使用换行符换行，需要加上样式`white-space: pre-wrap;`才能使换行符生效。
* 行内元素、行内块元素在使用margin:auto居中时，需要转换成块元素。比如img。





------



## 7.28

重大活动管理

* vite

  * vite中使用tsx：
    * jsx需要引入插件vuejsx
    * ts直接lang="ts"或lang="tsx"即可

* vue3+ts

* >Enable Preview
  >
  >控制打开的编辑器是否显示为预览编辑器。预览编辑器不会保持打开状态，在将其显式设置为保持打开(例如通过双击或编辑)前将会重复使用，其文件名显示样式为斜体。
  >

* defineComponent:

  应该是因为在顶层setup中，没有export defualt，因此通过该API定义组件以供导出。

  起到一个类似函数式组件的效果。

### tsx

* 泛型组件
* vue中无法在tsx中使用的组件：
  * v-on：需要像react一样写成`on事件名`
  * v-for：需要像react一样用map

## 7.29

* vite中import()函数不能动态导入，不能接收变量
* ts中如何只为对象的某一字段指定类型？

### vueRouter

* setup函数与setup语法糖：

  * useRouter等hooks只能在setup中使用，如果单独封装函数，应当把router对象作为参数传入。
  * setup函数中，props需要单独作为options定义，不能使用defineProps。

  

* 原本的route路径对象通过router.currentRoute.value获取，比如可以通过`router.currentRoute.value.path`获取当前页面的路由

* 可以通过router.getsRoute和router.addRoute获取当前路由，判断，再注册新路由。

## 8.1

### jsx插槽

* 父组件：以对象形式，直接在子组件textNode部分传值，以对象形式，每个插槽传一个返回jsx的函数。

  ```jsx
  setup() {
      const slot = () => <h2>test</h2>
      return () => (
          <div className="Father-container">
          <h2 >Father组件</h2>
          <Son>
          {{
          customSlot: slot,
          default: () => <h2>default</h2>
  }}
      </Son>
  </div>
  )
  }
  ```

* 子组件

  * setup通过context.slots拿到所有插槽。
  * 以调用函数的形式`default?.()`来使用插槽，注意类型判断。

  ```js
   setup(props, { slots }) {
          console.log(slots)
          console.log(slots.customSlot)
          return () => (
              <>
                  <h2>Son组件</h2>
                  {slots.customSlot?.()}
                  {slots.default?.()}
              </>
          )
      }
  ```

  

* 待会再看看作用域插槽如何传值

## 8.4

* vue `<Transition>`中的组件，使用jsx时，不能用`<></>`包裹，否则会导致组件不动（can not be animated）。

* https://www.typescriptlang.org/
* ts declare 命名空间的问题 vite

## 8.5

* ref变量在tsx挂载到DOM attr上时，不可以自动浅解包。

  DOM text也不行。tsx应该就不能自动浅解包。

* vscode复制路径，设置分隔符： Copy Relative Path Separator

* vue3 expose：

  * 子组件暴露：

    这里list为响应式数据，直接暴露。

    ```vue
    const list = ref([])
    
    expose({ list })
    ```

  * 父组件访问：

    通过ref直接拿到expose的对象。

    ```jsx
    <ReactiveTable requestList={listMonitor} ref={reactiveTableExpose} />
    ```

    直接通过

    ```js
    reactiveTableExpose?.value?.list
    ```

    拿到list。这里的list类型是Reactive(Array[])，即响应式数据

## 8.7

* Object.defineProperty(obj,key,{value,writable,configurable})

  writable和configurable默认为false，即如果只传入一个value，该property不可修改也不可删除。

## 8.8

* vue应该只能在组件的render函数的jsx中使用组件，无法在普通jsx中注册并使用组件。

## 8.10

* vite 2中只能使用较老版本的plugin-vue-jsx，现在用的1.3.3，具体版本对应还不太清楚。
* api json取数据时首字母要大写。

## 8.11

* echarts:多个y轴时，series中的data需要通过yAxisIndex进行匹配。

* js在对象中使用对象解构是有顺序的，与普通赋值一样，后赋值的覆盖先赋值的。

  ```js
  const obj1 = { a: 123, b: 'qwer' }
  const obj2 = { a: 2222, b: 'tttt', ...obj1 } // {a:123,b:'qwer'}
  const obj3 = { ...obj1, a: 2222, b: 'tttt' } // {a:2222,b:'tttt'}
  ```

* js的`array.join()`方法不传参时默认分隔符为`,`，如果需要空字符串的话要手动传入。

* 扩展运算符可以将string解构为arr：

  ```js
  [...'hello']
  ```

* grid布局：

  * 四宫格

    * content：

      ```css
        display: grid;
        grid-template-columns: 50% 50%;
        grid-template-rows: 50% 50%;
      ```

    * item：

  * 三盒子并排：

    ```css
      display: grid;
      grid-template-columns: repeat(3, 33.3%);
      column-gap: 10px;
    ```

    

* import.meta.glob怎么用？

  动态url引入问题

## 8.13

* string.padStart/string.padEnd  (targetLength,paddingString)：使用paddingString将字符串填充到目标长度，从头/尾部开始填充，重复填充。
  * 可用于使用空格让两组字符串之间的距离相等。

## 8.15

* git reflog 可以查看本地的一些日志 

* js 函数 使用默认参数，如果调用时手动传入undefined，也会使用默认参数。

* 如果使用

  ```js
  if(!res.xxx) {throw 'error'}
  ```

  这样的方式来判断该字段是否存在，可能会将值为数字0的字段也筛出去。

  可以使用

  ```js
  if(res.xxx == undefined) {throw 'error'}
  ```

* vue中如果使用reactive([])数组的forEach，对数组中的对象元素赋值，会出现问题。

* vue中也可以像react一样使用css module：
  * css标签加上module，替代原先scoped。

  * setup中使用useCssModule()钩子获得当前sfc的css模块。

  * 使用方法与react相同。

  * 多类名可以使用如下方式：

    ```js
    style={['className1','className2'].join(' ')}
    ```

  * vue sfc scoped不会为script标签中，return函数中以外的部分添加hash值，因此如果在render函数以外使用jsx元素，会导致样式挂不到相应的类名上。

## 8.16

* echarts通过series中的label选项来显示对应数字，但symbol如果为none，label也不会显示。
* MDN：CSS **`linear-gradient()`** 函数用于创建一个表示两种或多种颜色线性渐变的图片，只能被用在image用的地方。
* try-catch不能捕获setTimeOut的异常，需要使用window.onerror

* echarts 手机端 不能识别十六进制的rgba格式颜色。

## 8.22

* yarn 源管理：yrm。

## 8.23

* 笔记本双屏：显示设置里，设置为扩展屏幕（不要设置成复制），根据设置的位置，鼠标可以进入扩展屏幕进行操作。

* ??运算符：当左边为null和undefined时，返回右边的值。用于设置默认值。

  注意不包括空字符串''。

  
